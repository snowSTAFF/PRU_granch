#ifndef _TRSBNI_HP_
#define _TRSBNI_HP_

#define reg1 R29
#define reg2 R28
#define reg3 R27
#define reg4 R26

.macro RBC 
.mparam IN, VALUE, COUNT, SPEED	//IN - входной регистр; VALUE - куда записывать данные
//COUNT - сколько бит будем принимать; SPEED - значение равняется 1\4 и 3\4 от скорости передатчика
//NOTE: считаем, что приемник и передатчик уже засинхронизированны. SPEED = SPEED/4 (от трансфера)
START:					// считаем, что начинаем работу с появлением 1-ы
	QBEQ ENDRECIVE, COUNT, 1	// Основный цикл, пока не примет n-1 бит
	CDELAY SPEED			// Ждем 1/4 времени. НУжно записать величину speed/2
	QBBS COME1, IN			// если 1-а, то переход. Иначе на COME0
COME0:					// в 1/4 времени был 0
	CDELAY SPEED*2			// смотрим на 3/4 времени
	QBBC SET0, IN			// Если 0 остался,то на метку установки 0. Иначе на SET1
SET1:					// Запись 1-ы в регистр
	SET VALUE.t0			// установка 1-ы. Сначала проходит старший разряд.
	LSL VALUE, VALUE, 1		// Смещаем в сторону старшего разряда
	SUB COUNT, COUNT, 1		// Приняли один бит
	CDELAY SPEED			// Ждем остаток времени.
	QBA START			// возврат на основную метку
COME1:					// в 1/4 времени была 1-а
	CDELAY SPEED*2 			// ждем ещё 3/4
	QBBS SET0, IN			// аналогично
	QBA SET1
SET0:
	CLR VALUE.t0
	LSL VALUE, VALUE, 1
	SUB COUNT, COUNT, 1
	CDELAY SPEED
	QBA START

ENDRECIVE:				// метка принятия последнего бита
	CDELAY SPEED			// принцип работы аналогичный
	QBBS ECOME1, IN
ECOME0:
	CDELAY SPEED*2
	QBBC ESET0, IN
ESET1:
	SET VALUE.t0
	CDELAY SPEED
	QBA END
ECOME1:
	CDELAY SPEED*2 
	QBBS ESET0, IN
	QBA ESET1
ESET0:
	CLR VALUE.t0
	CDELAY SPEED
END:
.endm


.macro 	TSYNC			// макрос синхронизации		
.mparam  OUT, del, INV 		// OUT - выбор выхода для синхронизации, del - половина периода синхронизации, INV = 1 - invers
START:
QBBS INVERS, INV
DEFAULT:
	CLR OUT
	CDELAY del*2		// полный период синхронизации
	SET OUT
	CDELAY del
	QBA END
INVERS:
	SET OUT
	CDELAY del*2
	CLR OUT
	CDELAY del
	QBA END
END:	
.endm

.macro	TBC				// Transfer Bipulse Code (пока только 4-е байта)
.mparam OUT, DATA, COUNT, SPEED	// OUT - выбор выхода для передачи, data - данные, LENGHT - число байт в пакете 
// speed - выбор скорости. SPEED - половина периода от 45 НС.
LAST1:				// последняя была 1-а
	QBEQ END, COUNT, 0	// как только пошлется последний бит, выход
	QBBC LAST10, DATA.t31   // считаем, что синхронизация фронтом из 0 в 1
LAST11:				// метка установки первого бита, если он 1
	CLR OUT			// 1-а формируется изменением полярности сигнала
	CDELAY SPEED		// Задержка, соответствующая половине периода
	SET OUT			
	CDELAY SPEED		// конец бита. Скорость соответствует 2*Speed
	SUB COUNT, COUNT, 1	// вычитаем бит из счетчика
	LSL DATA, DATA, 1	// сдвигаем следующий бит
	QBA LAST1		// переходим на метку, соответствующую прошлому фронту 
LAST10:				// метко прихода 0 после 1-ы
	CLR OUT			// 0-ю соответствует сигнал, который не изменился за период
	CDELAY SPEED*2
	SUB COUNT, COUNT, 1
	LSL DATA, DATA, 1
LAST0:				//последний был 0
	QBEQ END, COUNT, 0
	QBBS LAST01, DATA.t31
LAST00:				// аналогично с вышеизложенным
	SET OUT
	CDELAY SPEED*2
	SUB COUNT, COUNT, 1
	LSL DATA, DATA, 1
	QBA LAST0
LAST01: 
	SET OUT
	CDELAY SPEED
	CLR OUT
	CDELAY SPEED
	SUB COUNT, COUNT, 1
	LSL DATA, DATA, 1
	QBA LAST1
END:
.endm

.macro MIC					// Макрос для определения манчестерского кода любого байта.
.mparam dst, src 				// dst - должен быть минимум 16-и разрядный регистр приема, src - входной байт
INIT:
	LDI reg1, 8				// инициализация для счета 8 бит
START:						// главная метка цикла
	QBEQ END, reg1, 0			// Закончить, когда пройдут прочитает все биты
	SUB reg1, reg1, 1			
	QBBS SET1, src.t0			// если 0-ой бит 1-а, то на метку SET1
	QBBC CLR0, src.t0			// если 0-ой бит 0, то на метку CLR0
SET1:						// Запись в регистр dst соответствующий импульсный код 1: 1-0 (инверсия из-за сдвига вправо)
	CLR dst.t16
	LSR dst, dst, 1
	SET dst.t16
	LSR dst, dst, 1				// после записи двух бит, необходимо сдвинуть в сторону младших разрядов
	LSR src, src, 1				// сдвигаем, чтобы прочесть следующий бит
	QBA START
CLR0:						// запись в регистр dst импульсный код 0: 0-1 (инверсия из-за сдвига вправо)
	SET dst.t16
	LSR dst, dst, 1				
	CLR dst.t16
	LSR dst, dst, 1
	LSR src, src, 1
	QBA START
END:
.endm

.macro TRANSFM					// макрос отправки информации в среду Манчестерского кода
.mparam dst, src, del 				// dst - выходной пин, src - 16-и разрядный регистр
						// del - задержка: 2 - 9mbit, 4 - 6mbit, 8 - 3mbit
INIT:
	LDI reg1, 16				// для чтения 16 бит
	LDI reg2, del				
START:
	QBEQ END, reg1, 0			// выход, после прочтения 16-го бита
	SUB reg1, reg1, 1
	QBBS SET1, src.t0			// метка установки 1-ы на выходе
	QBBC CLR0, src.t0			// метка установки 0 на выходе
SET1:
	SET dst
	SUB reg2, reg2, 1
	QBNE SET1, reg2, 0			// цикл задержки сигнала
	LSR src, src, 1
	LDI reg2, del
	QBA START
CLR0:
	CLR dst
	SUB reg2, reg2, 1
	QBNE CLR0, reg2, 0			// цикл задержки сигнала
	LSR src, src, 1
	LDI reg2, del
	QBA START
END:
.endm

.macro RMC					// Макрос для перевода из манчестерского кода в байт
.mparam dst, src				// dst - куда запишется результат, src - 16-и разрядный регистр с импульсным кодом

INIT:
	LDI reg1, 0
START:
	QBBS CLR0, src.t1			// проверяет 2-ой бит ипульсного кода, чтобы установить 1 или 0
	CLR dst.t8				// цикл установки 1-го бита
	LSR dst, dst, 1
	LSR src, src, 2
	ADD reg1, reg1, 1
	QBEQ EXIT, reg1, 8			// выход, как только прочтется байт
	QBA START
CLR0:						//цикл установки 0.
	SET dst.t8	
	LSR dst, dst, 1
	LSR src, src, 2
	ADD reg1, reg1, 1
	QBEQ EXIT, reg1, 8
	QBA START

EXIT:
	LDI reg1, 0
.endm

.macro CDELAY					// макрос задержки
.mparam tm					// time определяет задержку. 1 - 25 ns.
INIT:	
	MOV reg1, 3*tm
LOOPA:
	SUB reg1, reg1, 1
	QBEQ EXIT, reg1, 0
	QBA LOOPA
EXIT:
	XOR reg1, reg1, reg1
.endm

.macro REC9			// Макрос приема данных с задержкой 9			
.mparam IN, OUT, COUNT  	// входные параметры: IN - вход GPIO; OUT - выходной регистр;
// COUNT - регистр, содержащий в себе число бит.
RECIVE:
	QBBS SET1X, IN   // проверяем 1 сейчас. Если нет, то сразу переход на 0
	QBEQ BACK, COUNT, 0
SET0X:
	WBC IN		// проверям, точно ли 0.
	CDELAY 9	// ждем 405 НС. До смены остается ещё 30 НС
	WBC IN		// вторая проверка. Debbug точка
	CDELAY 1	// после неё станет ясно, что пришло. Сигнал уже как 20 нс новый.
	QBBC SET00, IN  // пришел 0? Если нет, значит 1-ца. -25 нс.
SET01:			// ЗАписываем переход из 0 в 1
	CLR OUT.t1	// Записываем 01
	SET OUT.t0
	LSL OUT, OUT, 2	//смещаем. -45нс.
	CDELAY 9 		// Сигналу осталось минимум 30 нс. -405-40+480
	SUB COUNT, COUNT, 2	// принято 2-а байта. 25 нс.
	CDELAY 1		// -20 нс нового сигнала
	QBA RECIVE		// возвращаемся на прием. -25
SET00:				//записываем переход из 0 в 0
	CLR OUT.t1
	CLR OUT.t0
	LSL OUT, OUT, 2
	CDELAY 9
	SUB COUNT, COUNT, 2
	CDELAY 1
	QBA RECIVE		// возвращаемся на прием -25
SET1X:			// для установки 1-ы и....
	WBS IN		// аналогично с нулем
	CDELAY 9
	WBS IN
	CDELAY 1
	QBBS SET11, IN
SET10:
	SET OUT.t1
	CLR OUT.t0
	LSL OUT, OUT, 2
	CDELAY 9
	SUB COUNT, COUNT, 2
	CDELAY 1
	QBA RECIVE	// переход на прием
SET11:
	SET OUT.t1
	SET OUT.t0
	LSL OUT, OUT, 2
	CDELAY 9
	SUB COUNT, COUNT, 2
	CDELAY 1
	QBA RECIVE 	// переход на прием
BACK:			// метка записи значения
	LSR OUT, OUT, 2 // когда приходят последний 2 бита, то он сдвигаются влево. Это необходимо учесть

.endm

#endif //_TRSBNI_HP_
